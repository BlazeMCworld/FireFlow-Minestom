# Messages
error.already.coding=You are already coding on this space.
error.already.building=You are already building on this space.
error.already.contributor=This player is already a contributor.
error.already.lobby=You are already in the lobby.
error.already.playing=You are already playing on this space.
error.empty.contributors=This space has no contributors.
error.function.delete_command=You must use '/function delete' to delete a function.
error.function.exists=This function already exists.
error.function.in_use=This function is currently in use.
error.input.exists=This input already exists.
error.input.not_found=Unknown input.
error.internal=Internal Server Error
error.invalid.debug_group=Unknown debug group!
error.invalid.inset=Failed to inset value with specified type and value.
error.invalid.item=Invalid item.
error.invalid.player=Unknown player.
error.invalid.space=Unknown space.
error.invalid.text=Invalid text.
error.locked.connected=A connected node is locked by {0}.
error.locked=This node is locked by {0}.
error.mode.code=You must be in code mode to use this command.
error.needs.function=You must look at a function to do this.
error.needs.output=You must look at a node output for this.
error.needs.owner=You must be the owner of this space to use this command.
error.needs.permission=You are not allowed to do this.
error.needs.player=You must be a player to use this command.
error.needs.space=You must be in a space to use this command.
error.needs.subcommand=Missing subcommand.
error.not.contributor=This player is not a contributor.
error.output.exists=This output already exists.
error.output.not_found=Unknown output.
error.snippet.partial=Some parts of the snippet failed to load.
error.space.not_broken=This space is already marked as stable.
error.space.potentially_broken=Some parts of this space may be broken! To avoid damage to the files the space will not save until /space mark_stable is ran.
error.text.too_long=Text is too long.
error.unknown.item=Unknown item.
info.cpu_usage=CPU Usage:
info.debug.on_signal=Debug {0}! (from {1} of {2})
info.debug.value={0} (from {1} of {2})
info.space.timed_out=Timed out on current space.
reload.regular=Reloading Space!
reload.clear_code=Reloading Space! (Code Deleted)
reload.clear_world=Reloading Space! (World Deleted)
success.added.debug_point=Added debug point!
success.changed_icon=Changed space icon!
success.changed_name=Changed space name!
success.cleared.code=Cleared code.
success.cleared.builders=Cleared builder list.
success.cleared.developers=Cleared developer list.
success.cleared.world=Cleared world.
success.contributors.added=Added player to contributors.
success.contributors.cleared=Cleared contributor list.
success.contributors.list=Contributors:
success.contributors.removed=Removed player from contributors.
success.ignore.debug_group=Now ignoring debug group.
success.reload=Reloaded!
success.removed.debug_group=Removed debug group!
success.removed.debug_point=Removed debug point!
success.snippet.create=Created snippet containing {0} nodes! Click this message to copy the snippet data!
success.snippet.place=Placed snippet containing {0} nodes!
success.space.marked_stable=Marked space as stable, files will save again.
success.watch.debug_group=Now watching debug group.

# Types
type.any=Any
type.condition=Condition
type.dictionary=Dictionary
type.entity=Entity
type.item=Item
type.list=List
type.number=Number
type.particle=Particle
type.player=Player
type.position=Position
type.signal=Signal
type.string=String
type.text=Text
type.typed_list=List<{0}>
type.vector=Vector

# Node Categories
category.action=Actions
category.condition=Conditions
category.dictionary=Dictionary
category.effect=Effects
category.entity=Entities
category.event=Events
category.flow=Control Flow
category.function=Functions
category.info=Info
category.item=Item
category.list=Lists
category.number=Numbers
category.player=Players
category.position=Positions
category.root=All Nodes
category.string=String
category.text=Text
category.variable=Variables
category.vector=Vectors
category.world=World

# Nodes
node.absolute_number.title=Absolute Number
node.absolute_number.description=out#positive_value is the same as in#value, but never in the negatives.
node.absolute_number.input.value=Value
node.absolute_number.output.positive_value=Positive Value

node.add_numbers.title=Add Numbers
node.add_numbers.description=Adds the in#left and all in#right numbers together and returns the out#result.
node.add_numbers.input.left=Left
node.add_numbers.input.right=Right
node.add_numbers.output.result=Result

node.add_vectors.title=Add Vectors
node.add_vectors.description=Adds the in#first and the in#second vectors together and returns the out#result.
node.add_vectors.input.first=First
node.add_vectors.input.second=Second
node.add_vectors.output.result=Result

node.cache_value.base_title=Cache Value
node.cache_value.title=Cache {0}
node.cache_value.description=When the in#signal is received stores the value of in#store in the out#cache and then sends out#next signal.
node.cache_value.input.signal=Signal
node.cache_value.input.store=Store
node.cache_value.output.next=Next
node.cache_value.output.cache=Cache

node.cancel_event.title=Cancel Event
node.cancel_event.description=Prevents or allows the default behaviour of the current event depending on in#cancel. If the event is already in prevented/allowed or is not cancellable, out#failed will send a signal instead of out#next.
node.cancel_event.input.signal=Signal
node.cancel_event.input.cancel=Cancels
node.cancel_event.output.next=Next
node.cancel_event.output.failed=Failed

node.character_at.title=Character At
node.character_at.description=Returns the character at the in#position in the in#string. With 0 being the first character, and invalid characters will return an empty string.
node.character_at.input.string=String
node.character_at.input.index=Index
node.character_at.output.character=Character

node.combine_strings.title=Combine Strings
node.combine_strings.description=Adds all in#strings together inserting in#separator between each, forming out#combined.
node.combine_strings.input.separator=Separator
node.combine_strings.input.strings=Strings
node.combine_strings.output.combined=Combined

node.combine_texts.title=Combine Texts
node.combine_texts.description=Adds all in#texts together forming out#combined.
node.combine_texts.input.texts=Texts
node.combine_texts.output.combined=Combined

node.basic_noise.title=Basic Noise
node.basic_noise.description=Returns the noise value at the in#position. For 2d noise Y is being ignored. See https://auburn.github.io/FastNoiseLite/ for visualization.
node.basic_noise.input.noise_type=Noise Type
node.basic_noise.input.dimension=Dimension
node.basic_noise.input.position=Position
node.basic_noise.input.frequency=Frequency
node.basic_noise.input.octaves=Octaves
node.basic_noise.input.gain=Gain
node.basic_noise.input.lacunarity=Lacunarity
node.basic_noise.input.seed=Seed
node.basic_noise.output.output=Output

node.clamp_number.title=Clamp Number
node.clamp_number.description=out#output is the in#input but adjusted to be between in#min and in#max if it is outside of that range.
node.clamp_number.input.input=Input
node.clamp_number.input.min=Min
node.clamp_number.input.max=Max
node.clamp_number.output.output=Result

node.clear_inventory.title=Clear Inventory
node.clear_inventory.description=When the in#signal is received clears the inventory of the in#player and sends out#next signal.
node.clear_inventory.input.signal=Signal
node.clear_inventory.input.player=Player
node.clear_inventory.output.next=Next

node.create_list.title=Create {0} List
node.create_list.base_title=Create List
node.create_list.description=Creates a list initialized with in#content and returns it as out#list.
node.create_list.input.content=Content
node.create_list.output.list=List

node.conditional_and.title=Conditional And
node.conditional_and.description=out#result is only true, if in#primary and all in#others are true.
node.conditional_and.input.primary=Primary
node.conditional_and.input.others=Others
node.conditional_and.output.result=Result

node.conditional_choice.title=Conditional {0} Choice
node.conditional_choice.base_title=Conditional Choice
node.conditional_choice.description=Depending on in#condition returns either in#trueValue or in#falseValue as out#choice.
node.conditional_choice.input.trueValue=True
node.conditional_choice.input.falseValue=False
node.conditional_choice.input.condition=Condition
node.conditional_choice.output.choice=Choice

node.conditional_or.title=Conditional Or
node.conditional_or.description=out#result is true, if in#primary or at least one of in#others is true.
node.conditional_or.input.primary=Primary
node.conditional_or.input.others=Others
node.conditional_or.output.result=Result

node.decrement_variable.title=Decrement Variable
node.decrement_variable.description=When the in#signal is received decrements the in#name variable in the in#scope by 1 and sends out#next signal.
node.decrement_variable.input.signal=Signal
node.decrement_variable.input.name=Name
node.decrement_variable.input.scope=Scope
node.decrement_variable.output.next=Next

node.dictionary_get.title={0} {1} Dictionary Get
node.dictionary_get.base_title=Dictionary Get
node.dictionary_get.description=Returns the matching out#value based on the in#key in the in#dictionary.
node.dictionary_get.input.dictionary=Dictionary
node.dictionary_get.input.key=Key
node.dictionary_get.output.value=Value

node.dictionary_has.title={0} {1} Dictionary Has
node.dictionary_has.base_title=Dictionary Has
node.dictionary_has.description=Provides if there is an entry for the in#key in the in#dictionary as out#found.
node.dictionary_has.input.dictionary=Dictionary
node.dictionary_has.input.key=Key
node.dictionary_has.output.found=Found

node.dictionary_keys.title={0} {1} Dictionary Keys
node.dictionary_keys.base_title=Dictionary Keys
node.dictionary_keys.description=Provides a list of all keys found in the in#dictionary as out#keys.
node.dictionary_keys.input.dictionary=Dictionary
node.dictionary_keys.output.keys=Keys

node.dictionary_put.title={0} {1} Dictionary Put
node.dictionary_put.base_title=Dictionary Put
node.dictionary_put.description=Passes along the in#dictionary as out#updated with the entry corresponding to the in#key updated to the in#value.
node.dictionary_put.input.dictionary=Dictionary
node.dictionary_put.input.key=Key
node.dictionary_put.input.value=Value
node.dictionary_put.output.updated=Updated

node.dictionary_remove.title={0} {1} Dictionary Remove
node.dictionary_remove.base_title=Dictionary Remove
node.dictionary_remove.description=Passes along the in#dictionary as out#updated with the entry corresponding to the in#key removed.
node.dictionary_remove.input.dictionary=Dictionary
node.dictionary_remove.input.key=Key
node.dictionary_remove.output.updated=Updated

node.dictionary_size.title={0} {1} Dictionary Size
node.dictionary_size.base_title=Dictionary Size
node.dictionary_size.description=Provides the amount of entries in the in#dictionary as out#size.
node.dictionary_size.input.dictionary=Dictionary
node.dictionary_size.output.size=Size

node.divide_numbers.title=Divide Numbers
node.divide_numbers.description=Divides the in#left by all in#right numbers and returns the out#result.
node.divide_numbers.input.left=Left
node.divide_numbers.input.right=Right
node.divide_numbers.output.result=Result

node.facing_vector.title=Facing Vector
node.facing_vector.description=Returns a vector representing the direction the in#position is facing as out#vector.
node.facing_vector.input.position=Position
node.facing_vector.output.vector=Vector

node.format_to_text.title=Format to Text
node.format_to_text.description=Returns the in#string formatted using MiniMessage as out#text.
node.format_to_text.input.string=String
node.format_to_text.output.text=Text

node.get_block.title=Get Block
node.get_block.description=out#block is the identifier of the block at the in#position. For unloaded chunks returns an empty string.
node.get_block.input.position=Position
node.get_block.output.block=Block

node.get_experience_level.title=Get Experience Level
node.get_experience_level.description=Returns the experience level of the in#player as out#level.
node.get_experience_level.input.player=Player
node.get_experience_level.output.level=Level

node.get_experience_percentage.title=Get Experience Percentage
node.get_experience_percentage.description=Returns the experience percentage of the in#player as out#percentage in the range of 0 to 100.
node.get_experience_percentage.input.player=Player
node.get_experience_percentage.output.percentage=Percentage

node.get_held_slot.title=Get Held Slot
node.get_held_slot.description=Returns the slot the in#player is holding as out#slot. Starts at 1.
node.get_held_slot.input.player=Player
node.get_held_slot.output.slot=Slot

node.get_list_index.title=Get {0} List Index
node.get_list_index.base_title=Get List Index
node.get_list_index.description=Provides the value in the in#list at the in#index position as the out#value output. Starts counting at 0.
node.get_list_index.input.list=List
node.get_list_index.input.index=Index
node.get_list_index.output.value=Value

node.get_player_food.title=Get Player Food
node.get_player_food.description=Returns the food level of the in#player as out#food in the range of 0 to 20.
node.get_player_food.input.player=Player
node.get_player_food.output.food=Food

node.get_player_health.title=Get Player Health
node.get_player_health.description=Returns the health level of the in#player as out#health. Usually between 0 and 20.
node.get_player_health.input.player=Player
node.get_player_health.output.health=Health

node.get_player_name.title=Get Player Name
node.get_player_name.description=Returns the name of the in#player as out#name, returns an empty string if the player is not playing on the space.
node.get_player_name.input.player=Player
node.get_player_name.output.name=Name

node.get_player_saturation.title=Get Player Saturation
node.get_player_saturation.description=Returns the saturation level of the in#player as out#saturation. Usually between 0 and 20.
node.get_player_saturation.input.player=Player
node.get_player_saturation.output.saturation=Saturation

node.get_player_uuid.title=Get Player UUID
node.get_player_uuid.description=Returns the uuid of the in#player as out#uuid.
node.get_player_uuid.input.player=Player
node.get_player_uuid.output.uuid=UUID

node.get_variable.title=Get {0} Variable
node.get_variable.base_title=Get Variable
node.get_variable.description=Returns the value of the in#name variable in the in#scope as out#value.
node.get_variable.input.name=Name
node.get_variable.input.scope=Scope
node.get_variable.output.value=Value

node.get_vector_component.title=Get Vector Component
node.get_vector_component.description=Returns the value of the in#axis of the in#vector as out#component.
node.get_vector_component.input.vector=Vector
node.get_vector_component.input.axis=Axis
node.get_vector_component.output.output=Component

node.give_player_item.title=Give Player Item
node.give_player_item.description=When the in#signal is received gives the in#item to the in#player and sends out#next signal.
node.give_player_item.input.signal=Signal
node.give_player_item.input.player=Player
node.give_player_item.input.item=Item
node.give_player_item.output.next=Next

node.greater_than.title=Greater Than
node.greater_than.description=out#result is true if in#left is greater than in#right. False otherwise.
node.greater_than.input.left=Left
node.greater_than.input.right=Right
node.greater_than.output.result=Result

node.greater_equal.title=Greater Equal
node.greater_equal.description=out#result is true if in#left is greater than or equal to in#right. False otherwise.
node.greater_equal.input.left=Left
node.greater_equal.input.right=Right
node.greater_equal.output.result=Result

node.increment_variable.title=Increment Variable
node.increment_variable.description=When the in#signal is received increments the in#name variable in the in#scope by 1 and sends out#next signal.
node.increment_variable.input.signal=Signal
node.increment_variable.input.name=Name
node.increment_variable.input.scope=Scope
node.increment_variable.output.next=Next

node.index_in_list.title=Index in {0} List
node.index_in_list.base_title=Index in List
node.index_in_list.description=out#index is the index of the in#value in the in#list. Starts counting at 0. Returns -1 if the value is not found.
node.index_in_list.input.list=List
node.index_in_list.input.value=Value
node.index_in_list.output.index=Index

node.items_equal.title=Items Equal
node.items_equal.description=out#case is true if the in#first and in#second items are equal. Ignores the item stack count unless in#checkCount is true.
node.items_equal.input.First=First
node.items_equal.input.second=Second
node.items_equal.input.check_count=Check Count
node.items_equal.output.case=Case

node.less_than.title=Less Than
node.less_than.description=out#result is true if in#left is less than in#right. False otherwise.
node.less_than.input.left=Left
node.less_than.input.right=Right
node.less_than.output.result=Result

node.less_equal.title=Less Equal
node.less_equal.description=out#result is true if in#left is less than or equal to in#right. False otherwise.
node.less_equal.input.left=Left
node.less_equal.input.right=Right
node.less_equal.output.result=Result

node.if.title=If
node.if.description=When the in#signal is received sends out#true if in#condition is true and out#false if it is false.
node.if.input.condition=Condition
node.if.input.signal=Signal
node.if.output.false=False
node.if.output.true=True

node.invert_condition.title=Invert Condition
node.invert_condition.description=out#inverted is true if in#normal is false, and vice versa.
node.invert_condition.input.normal=Normal
node.invert_condition.output.inverted=Inverted

node.is_player_invulnerable.title=Is Player Invulnerable
node.is_player_invulnerable.description=out#invulnerable is true if the in#player is invulnerable.
node.is_player_invulnerable.input.player=Player
node.is_player_invulnerable.output.invulnerable=Invulnerable

node.is_player_sneaking.title=Is Player Sneaking
node.is_player_sneaking.description=out#sneaking is true if the in#player is sneaking.
node.is_player_sneaking.input.signal=Signal
node.is_player_sneaking.input.player=Player
node.is_player_sneaking.output.next=Next
node.is_player_sneaking.output.sneaking=Sneaking

node.is_playing.title=Is Playing
node.is_playing.description=out#playing is true if the in#player is currently playing on this space.
node.is_playing.input.player=Player
node.is_playing.output.playing=Playing

node.kill_player.title=Kill Player
node.kill_player.description=When the in#signal is received kills the in#player and sends out#next signal.
node.kill_player.input.signal=Signal
node.kill_player.input.player=Player
node.kill_player.output.next=Next

node.list_append.title={0} List Append
node.list_append.base_title=List Append
node.list_append.description=Appends the in#value to the in#list and returns the updated list as out#list. Does not modify the original list.
node.list_append.input.list=List
node.list_append.input.value=Value
node.list_append.output.list=List

node.list_contains.title={0} List Contains
node.list_contains.base_title=List Contains
node.list_contains.description=Checks if the in#list contains all the in#check values and sets out#contains accordingly.
node.list_contains.input.list=List
node.list_contains.input.check=Check
node.list_contains.output.contains=Contains

node.list_for_each.title={0} List For Each
node.list_for_each.base_title=List For Each
node.list_for_each.description=Iterates over the entire in#list and sets the in#value to the current value and then sends out#each for it. Once done sends out#next signal.
node.list_for_each.input.signal=Signal
node.list_for_each.input.list=List
node.list_for_each.output.each=Each
node.list_for_each.output.value=Value
node.list_for_each.output.next=Next

node.list_insert.title={0} List Insert
node.list_insert.base_title=List Insert
node.list_insert.description=Inserts the in#value at the in#index position in the in#list and returns the updated list as out#list. Does not modify the original list.
node.list_insert.input.list=List
node.list_insert.input.value=Value
node.list_insert.input.index=Index
node.list_insert.output.list=List

node.list_length.title={0} List Length
node.list_length.base_title=List Length
node.list_length.description=The out#length is the amount of values the in#list holds.
node.list_length.input.list=List
node.list_length.output.length=Length

node.modulo_number.title=Modulo
node.modulo_number.description=out#output is the remaining value of in#left when divided by in#right. Gets wrapped around if it would be negative.
node.modulo_number.input.left=Left
node.modulo_number.input.right=Right
node.modulo_number.output.output=Output

node.multiply_numbers.title=Multiply Numbers
node.multiply_numbers.description=out#result is the product of in#left and in#right.
node.multiply_numbers.input.left=Left
node.multiply_numbers.input.right=Right
node.multiply_numbers.output.result=Result

node.on_chunk_load.title=On Chunk Load
node.on_chunk_load.description=When a chunk is loaded sends out#signal with the chunk coordinates. The out#x and out#z are the corner coordinates of the chunk in world space.
node.on_chunk_load.output.signal=Signal
node.on_chunk_load.output.x=Chunk X
node.on_chunk_load.output.z=Chunk Z

node.on_player_attack_player.title=On Player Attack Player
node.on_player_attack_player.description=When one player attacks another sends out#signal with the out#source being the attacker and out#target being the victim.
node.on_player_attack_player.output.signal=Signal
node.on_player_attack_player.output.source=Source
node.on_player_attack_player.output.target=Target

node.on_player_chat.title=On Player Chat
node.on_player_chat.description=When a player sends a chat message sends out#signal with the out#message and out#player set to their respective values.
node.on_player_chat.output.message=Message
node.on_player_chat.output.signal=Signal
node.on_player_chat.output.player=Player

node.on_player_click_block.title=On Player Click Block
node.on_player_click_block.description=When a player clicks on a block sends out#signal with the out#player being the player and out#position being the block position.
node.on_player_click_block.output.signal=Signal
node.on_player_click_block.output.player=Player
node.on_player_click_block.output.position=Position

node.on_player_join.title=On Player Join
node.on_player_join.description=When a player joins sends out#signal with the out#player set to who joined.
node.on_player_join.output.signal=Signal
node.on_player_join.output.player=Player

node.on_player_start_flying.title=On Player Start Flying
node.on_player_start_flying.description=When a player starts flying sends out#signal with the out#player set to who started flying.
node.on_player_start_flying.output.signal=Signal
node.on_player_start_flying.output.player=Player

node.on_player_start_gliding.title=On Player Start Gliding
node.on_player_start_gliding.description=When a player starts gliding with an elytra sends out#signal with the out#player set to who started gliding.
node.on_player_start_gliding.output.signal=Signal
node.on_player_start_gliding.output.player=Player

node.on_player_start_sneaking.title=On Player Start Sneaking
node.on_player_start_sneaking.description=When a player starts sneaking sends out#signal with the out#player set to who started sneaking.
node.on_player_start_sneaking.output.signal=Signal
node.on_player_start_sneaking.output.player=Player

node.on_player_start_sprinting.title=On Player Start Sprinting
node.on_player_start_sprinting.description=When a player starts sprinting sends out#signal with the out#player set to who started sprinting.
node.on_player_start_sprinting.output.signal=Signal
node.on_player_start_sprinting.output.player=Player

node.on_player_stop_flying.title=On Player Stop Flying
node.on_player_stop_flying.description=When a player stops flying sends out#signal with the out#player set to who stopped flying.
node.on_player_stop_flying.output.signal=Signal
node.on_player_stop_flying.output.player=Player

node.on_player_stop_gliding.title=On Player Stop Gliding
node.on_player_stop_gliding.description=When a player stops gliding with an elytra sends out#signal with the out#player set to who stopped gliding.
node.on_player_stop_gliding.output.signal=Signal
node.on_player_stop_gliding.output.player=Player

node.on_player_stop_sneaking.title=On Player Stop Sneaking
node.on_player_stop_sneaking.description=When a player stops sneaking sends out#signal with the out#player set to who stopped sneaking.
node.on_player_stop_sneaking.output.signal=Signal
node.on_player_stop_sneaking.output.player=Player

node.on_player_stop_sprinting.title=On Player Stop Sprinting
node.on_player_stop_sprinting.description=When a player stops sprinting sends out#signal with the out#player set to who stopped sprinting.
node.on_player_stop_sprinting.output.signal=Signal
node.on_player_stop_sprinting.output.player=Player

node.on_player_use_item.title=On Player Use Item
node.on_player_use_item.description=When a player uses an item sends out#signal with the out#player and out#item set to who used the item.
node.on_player_use_item.output.signal=Signal
node.on_player_use_item.output.player=Player
node.on_player_use_item.output.item=Item

node.pack_position.title=Pack Position
node.pack_position.description=Combines the in#x, in#y, in#z, in#pitch, and in#yaw values into a position provided by out#position.
node.pack_position.input.x=X
node.pack_position.input.y=Y
node.pack_position.input.z=Z
node.pack_position.input.pitch=Pitch
node.pack_position.input.yaw=Yaw
node.pack_position.output.position=Position

node.pack_vector.title=Pack Vector
node.pack_vector.description=Combines the in#x, in#y, and in#z values into a vector provided by out#vector.
node.pack_vector.input.x=X
node.pack_vector.input.y=Y
node.pack_vector.input.z=Z
node.pack_vector.output.vector=Vector

node.parse_number.title=Parse Number
node.parse_number.description=out#number is the number representation of in#string. Returns 0 if the string is not a valid number.
node.parse_number.input.string=String
node.parse_number.output.number=Number

node.pause_thread.title=Pause Thread
node.pause_thread.description=When the in#signal is received pauses the current thread for in#ticks, then sends the out#next signal.
node.pause_thread.input.signal=Signal
node.pause_thread.input.ticks=Ticks
node.pause_thread.output.next=Next

node.player_animation.title=Player Animation
node.player_animation.description=Displays the in#animation on the in#player.
node.player_animation.input.signal=Signal
node.player_animation.input.player=Player
node.player_animation.input.animation=Animation
node.player_animation.output.next=Next

node.player_from_name.title=Player From Name
node.player_from_name.description=out#player is the player with the matching in#name. Only works for players actively playing on the space.
node.player_from_name.input.name=Name
node.player_from_name.output.player=Player

node.player_from_uuid.title=Player From UUID
node.player_from_uuid.description=out#player is the player with the matching in#uuid.
node.player_from_uuid.input.uuid=UUID
node.player_from_uuid.output.player=Player

node.player_can_fly.title=Player Can Fly
node.player_can_fly.description=out#allowed is true if the in#player can fly.
node.player_can_fly.input.player=Player
node.player_can_fly.output.allowed=Allowed

node.player_is_flying.title=Player Is Flying
node.player_is_flying.description=out#flying is true if the in#player is flying.
node.player_is_flying.input.player=Player
node.player_is_flying.output.flying=Flying

node.player_list.title=Player List
node.player_list.description=out#players is a list of all players currently playing on the space.
node.player_list.output.players=Players

node.player_main_item.title=Player Main Item
node.player_main_item.description=out#item is the main item currently held by the in#player.
node.player_main_item.input.player=Player
node.player_main_item.output.item=Item

node.player_position.title=Player Position
node.player_position.description=out#position is the current position of the in#player.
node.player_position.input.player=Player
node.player_position.output.position=Position

node.random_number.title=Random Number
node.random_number.description=out#output is a random number between on in#min and in#max. If Mode is Decimal, the number can have any amount of decimal places. For WholeInclusive and WholeExclusive, the number will be a whole number without decimal places. For WholeExclusive the outputs can not contain the maximum value.
node.random_number.input.mode=Mode
node.random_number.input.min=Min
node.random_number.input.max=Max
node.random_number.output.output=Output

node.remainder_number.title=Remainder
node.remainder_number.description=out#output is the remaining value of in#left when divided by in#right. Can be negative.
node.remainder_number.input.left=Left
node.remainder_number.input.right=Right
node.remainder_number.output.output=Output

node.remove_entity.title=Remove Entity
node.remove_entity.description=When the in#signal is received removes the in#entity and sends out#next signal.
node.remove_entity.input.signal=Signal
node.remove_entity.input.entity=Entity
node.remove_entity.output.next=Next

node.remove_list_index.title=Remove {0} List Index
node.remove_list_index.base_title=Remove List Index
node.remove_list_index.description=Passes along the contents of the in#list to the out#list output, removing the entry at the in#index position. Starts counting at 0.
node.remove_list_index.input.list=List
node.remove_list_index.input.index=Index
node.remove_list_index.output.list=List

node.remove_list_value.title=Remove {0} List Value
node.remove_list_value.base_title=Remove List Value
node.remove_list_value.description=Passes along the contents of the in#list to the out#list output, removing all values matching the in#value.
node.remove_list_value.input.list=List
node.remove_list_value.input.value=Value
node.remove_list_value.output.list=List

node.repeat.title=Repeat
node.repeat.description=When the in#signal is received repeats in#times sending out #out#repeat with the out#index as the currenty index. Then sends and out#next as the next signal. The out#index starts at 0.
node.repeat.input.signal=Signal
node.repeat.input.times=Times
node.repeat.output.repeat=Repeat
node.repeat.output.index=Index
node.repeat.output.next=Next

node.respawn_player.title=Respawn Player
node.respawn_player.description=When the in#signal is received respawns the in#player and then sends out#next signal.
node.respawn_player.input.signal=Signal
node.respawn_player.input.player=Player
node.respawn_player.output.next=Next

node.round_number.title=Round Number
node.round_number.description=out#result is the rounded number of in#value. Depending on the in#mode, the number will be up or down. in#decimal_place is the amount of decimal places to keep. For example 1 for an output precision of 0.1 or -1 for a precision of 10.
node.round_number.input.value=Value
node.round_number.input.mode=Mode
node.round_number.input.decimal_place=Decimal Place
node.round_number.output.result=Result

node.round_vector_axes.title=Round Vector Axes
node.round_vector_axes.description=Rounds each of the axes of the in#vector depending on the in#mode and provides the output as out#rounded.
node.round_vector_axes.input.vector=Vector
node.round_vector_axes.input.mode=Mode
node.round_vector_axes.output.rounded=Rounded

node.schedule.title=Schedule
node.schedule.description=When the in#signal is received schedules the out#task to run in in#delay ticks. Immediately sends out#now,
node.schedule.input.signal=Signal
node.schedule.input.delay=Delay
node.schedule.output.now=Now
node.schedule.output.task=Task

node.send_actionbar.title=Send Actionbar
node.send_actionbar.description=When the in#signal is received sends the in#message to the in#player actionbar, then sends out#next.
node.send_actionbar.input.signal=Signal
node.send_actionbar.input.player=Player
node.send_actionbar.input.message=Message
node.send_actionbar.output.next=Next

node.send_block_change.title=Send Block Change
node.send_block_change.description=When the in#signal is received sends the in#player an in#block at the in#position, only visible to them, then sends out#next.
node.send_block_change.input.signal=Signal
node.send_block_change.input.block=Block
node.send_block_change.input.position=Position
node.send_block_change.output.next=Next
node.send_block_change.input.player=Player

node.send_message.title=Send Message
node.send_message.description=When the in#signal is received sends the in#message to the in#player, then sends out#next.
node.send_message.input.signal=Signal
node.send_message.input.player=Player
node.send_message.input.message=Message
node.send_message.output.next=Next

node.send_particle.title=Send Particle
node.send_particle.description=Shows the in#player the in#particle in#count times at in#position.
node.send_particle.input.signal=Signal
node.send_particle.input.player=Player
node.send_particle.input.position=Position
node.send_particle.input.particle=Particle
node.send_particle.input.count=Count
node.send_particle.output.next=Next

node.send_title.title=Send Title
node.send_title.description=When the in#signal is received sends a title to the in#player, then sends out#next. The title with slowly appear within in#fade_in ticks and stay for in#stay ticks and finally disappear within in#fade_out ticks. Both in#title and in#subtitle can be empty.
node.send_title.input.signal=Signal
node.send_title.input.player=Player
node.send_title.input.title=Title
node.send_title.input.subtitle=Subtitle
node.send_title.input.fade_in=Fade In
node.send_title.input.stay=Stay
node.send_title.input.fade_out=Fade Out
node.send_title.output.next=Next

node.set_allow_flying.title=Set Allow Flying
node.set_allow_flying.description=When the in#signal is received sets the in#player's ability to fly to in#allow, then sends out#next.
node.set_allow_flying.input.signal=Signal
node.set_allow_flying.input.player=Player
node.set_allow_flying.input.allow=Allow
node.set_allow_flying.output.next=Next

node.set_block.title=Set Block
node.set_block.description=When the in#signal is received sets the block at the in#position to in#block, then sends out#next.
node.set_block.input.signal=Signal
node.set_block.input.position=Position
node.set_block.input.block=Block
node.set_block.output.next=Next

node.set_experience_level.title=Set Experience Level
node.set_experience_level.description=When the in#signal is received sets the experience level of the in#player to in#level, then sends out#next.
node.set_experience_level.input.signal=Signal
node.set_experience_level.input.player=Player
node.set_experience_level.input.level=Level
node.set_experience_level.output.next=Next

node.set_experience_percentage.title=Set Player Experience
node.set_experience_percentage.description=When the in#signal is received sets the experience percentage of the in#player to in#percentage, then sends out#next. The percentage should be between 0 and 100.
node.set_experience_percentage.input.signal=Signal
node.set_experience_percentage.input.player=Player
node.set_experience_percentage.input.percentage=Percentage
node.set_experience_percentage.output.next=Next

node.set_gamemode.title=Set Gamemode
node.set_gamemode.description=When the in#signal is received changes the gamemode of the in#player to in#gamemode, then sends out#next.
node.set_gamemode.input.signal=Signal
node.set_gamemode.input.player=Player
node.set_gamemode.input.gamemode=Gamemode
node.set_gamemode.output.next=Next

node.set_held_slot.title=Set Held Slot
node.set_held_slot.description=When the in#signal is received changes the held slot of the in#player to in#slot, then sends out#next. Starts at 1.
node.set_held_slot.input.signal=Signal
node.set_held_slot.input.player=Player
node.set_held_slot.input.slot=Slot
node.set_held_slot.output.next=Next

node.set_item_count.title=Set Item Count
node.set_item_count.description=Passes along the in#item as out#updated with the count changed to in#count.
node.set_item_count.input.item=Item
node.set_item_count.input.count=Count
node.set_item_count.output.updated=Updated

node.set_item_lore.title=Set Item Lore
node.set_item_lore.description=Passes along the in#item as out#updated with the lore changed to in#lore.
node.set_item_lore.input.item=Item
node.set_item_lore.input.lore=Lore
node.set_item_lore.output.updated=Updated

node.set_item_material.title=Set Item Material
node.set_item_material.description=Changes the material of the in#item to in#material and returns the updated item as out#updated.
node.set_item_material.input.item=Item
node.set_item_material.input.material=Material
node.set_item_material.output.updated=Updated

node.set_item_name.title=Set Item Name
node.set_item_name.description=Passes along the in#item as out#updated with the name changed to in#name.
node.set_item_name.input.item=Item
node.set_item_name.input.name=Name
node.set_item_name.output.updated=Updated

node.set_list_index.title=Set {0} List Index
node.set_list_index.base_title=Set List Index
node.set_list_index.description=Passes along the in#list as out#updated with the value at the in#index position changed to in#value. Starts counting at 0.
node.set_list_index.input.list=List
node.set_list_index.input.index=Index
node.set_list_index.input.value=Value
node.set_list_index.output.updated=Updated

node.set_player_flying.title=Set Player Flying
node.set_player_flying.description=When the in#signal is received sets the in#player's current flying status to in#flying, then sends out#next.
node.set_player_flying.input.signal=Signal
node.set_player_flying.input.player=Player
node.set_player_flying.input.flying=Flying
node.set_player_flying.output.next=Next

node.set_player_food.title=Set Player Food
node.set_player_food.description=When the in#signal is received sets the in#player's food to in#food, then sends out#next. The food should be between 0 and 20.
node.set_player_food.input.signal=Signal
node.set_player_food.input.player=Player
node.set_player_food.input.food=Food
node.set_player_food.output.next=Next

node.set_player_health.title=Set Player Health
node.set_player_health.description=When the in#signal is received sets the in#player's health to in#health, then sends out#next. The health should be between 0 and 20.
node.set_player_health.input.signal=Signal
node.set_player_health.input.player=Player
node.set_player_health.input.health=Health
node.set_player_health.output.next=Next

node.set_player_invulnerable.title=Set Player Invulnerable
node.set_player_invulnerable.description=When the in#signal is either makes the in#player invulnerable if in#state is true or makes the in#player vulnerable if in#state is false, then sends out#next.
node.set_player_invulnerable.input.signal=Signal
node.set_player_invulnerable.input.player=Player
node.set_player_invulnerable.input.state=State
node.set_player_invulnerable.output.next=Next

node.set_player_saturation.title=Set Player Saturation
node.set_player_saturation.description=When the in#signal is received sets the in#player's saturation to in#saturation, then sends out#next. The saturation should be between 0 and 20.
node.set_player_saturation.input.signal=Signal
node.set_player_saturation.input.player=Player
node.set_player_saturation.input.saturation=Saturation
node.set_player_saturation.output.next=Next

node.set_player_velocity.title=Set Player Velocity
node.set_player_velocity.description=When the in#signal is received sets the in#player's velocity to in#velocity, then sends out#next.
node.set_player_velocity.input.signal=Signal
node.set_player_velocity.input.player=Player
node.set_player_velocity.input.velocity=Velocity
node.set_player_velocity.output.next=Next

node.set_to_exponential.title=Set To Exponential
node.set_to_exponential.description=out#result is the number in#value raised to the power of in#exponent.
node.set_to_exponential.input.base=Base
node.set_to_exponential.input.exponent=Exponent
node.set_to_exponential.output.result=Result

node.set_variable.title=Set {0} Variable
node.set_variable.base_title=Set Variable
node.set_variable.description=When the in#signal is received sets the in#name variable in the in#scope to in#value, then sends out#next.
node.set_variable.input.signal=Signal
node.set_variable.input.name=Name
node.set_variable.input.value=Value
node.set_variable.input.scope=Scope
node.set_variable.output.next=Next

node.set_region.title=Set Region
node.set_region.description=When the in#signal is received sets all blocks in the region from in#corner1 to in#corner2 to in#block, immediately sends out#now and after all blocks are set sends out#then.
node.set_region.input.signal=Signal
node.set_region.input.corner1=Corner1
node.set_region.input.corner2=Corner2
node.set_region.input.block=Block
node.set_region.output.now=Now
node.set_region.output.then=Then

node.set_vector_component.title=Set Vector Component
node.set_vector_component.description=out#result is the same vector as in#vector but with in#axis set to in#value.
node.set_vector_component.input.vector=Vector
node.set_vector_component.input.axis=Axis
node.set_vector_component.input.value=Value
node.set_vector_component.output.output=Result

node.set_vector_length.title=Set Vector Length
node.set_vector_length.description=out#scaled is the same vector as in#vector but updated to be in#length long.
node.set_vector_length.input.vector=Vector
node.set_vector_length.input.length=Length
node.set_vector_length.output.scaled=Scaled

node.spawn_entity.title=Spawn Entity
node.spawn_entity.description=Spawns a new entity based on the in#type at in#position. The spawned entity is available as out#entity.
node.spawn_entity.input.signal=Signal
node.spawn_entity.input.type=Type
node.spawn_entity.input.position=Position
node.spawn_entity.output.next=Next
node.spawn_entity.output.entity=Entity

node.square_root.title=Square Root Number
node.square_root.description=Returns the square root of in#number
node.square_root.input.number=Number
node.square_root.output.result=Result

node.string_length.title=String Length
node.string_length.description=out#length is the length of in#string in characters.
node.string_length.input.string=String
node.string_length.output.length=Length

node.subtract_numbers.title=Subtract Numbers
node.subtract_numbers.description=out#result is the difference of in#left and all in#right.
node.subtract_numbers.input.left=Left
node.subtract_numbers.input.right=Right
node.subtract_numbers.output.result=Result

node.teleport_entity.title=Teleport Entity
node.teleport_entity.description=When the in#signal is received teleports the in#entity to in#position, then sends out#next.
node.teleport_entity.input.signal=Signal
node.teleport_entity.input.entity=Entity
node.teleport_entity.input.position=Position
node.teleport_entity.output.next=Next

node.teleport_player.title=Teleport Player
node.teleport_player.description=When the in#signal is received teleports the in#player to in#position, then sends out#next.
node.teleport_player.input.signal=Signal
node.teleport_player.input.player=Player
node.teleport_player.input.position=Position
node.teleport_player.output.next=Next

node.unpack_position.title=Unpack Position
node.unpack_position.description=Supplies the components of in#position as out#x, out#y, out#z, out#pitch, and out#yaw.
node.unpack_position.input.position=Position
node.unpack_position.output.x=X
node.unpack_position.output.y=Y
node.unpack_position.output.z=Z
node.unpack_position.output.pitch=Pitch
node.unpack_position.output.yaw=Yaw

node.unpack_vector.title=Unpack Vector
node.unpack_vector.description=Supplies the components of in#vector as out#x, out#y, out#z
node.unpack_vector.input.vector=Vector
node.unpack_vector.output.x=X
node.unpack_vector.output.y=Y
node.unpack_vector.output.z=Z

node.values_equal.base_title=Values Equal
node.values_equal.title={0} Values Equal
node.values_equal.description=out#equal is true if the in#primary and all in#others are equal.
node.values_equal.input.primary=Primary
node.values_equal.input.others=Others
node.values_equal.output.equal=Equal

node.while.title=While
node.while.description=Repeats the in#repeat signal as long as the in#condition is true. When the in#condition is false sends out#next.
node.while.input.signal=Signal
node.while.input.condition=Condition
node.while.output.repeat=Repeat
node.while.output.next=Next